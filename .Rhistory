#' Si quisiésemos comparar el ajuste de distintos modelos se podría considerar el valor mínimo de la función objetivo WLS, almacenado como un atributo del resultado (aunque la recomendación sería emplear validación cruzada):
#'
attr(fit2, "SSErr")
#'
#' En cualquier caso la recomendación es analizar gráficamente el ajuste de los modelos.
#' Para representar las estimaciones empíricas junto con un único ajuste, se
#' podría emplear `plot.gstatVariogram()`:
#'
# Cuidado con plot.variogramModel() si se pretende añadir elementos
# plot(fit, cutoff = maxlag, ylim = c(0, 4.5))
# with(vario,  points(dist, gamma))
plot(vario, fit2)
# abline(v = range) # No se dibuja donde debería
#'
#' Para añadir más elementos mejor hacerlo "a mano":
#'
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit2, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range, lty = 3)
abline(h = 0, lty = 3)
abline(h = nugget, lty = 3)
abline(h = sill, lty = 3)
#'
#' ## Predicción espacial (KU)
#'
#' Para generar la rejilla de predicción consideramos un buffer de radio 40 en torno a las posiciones espaciales:
#'
buffer <- aquifer_sf %>% st_geometry() %>% st_buffer(40)
#'
#' En lugar de emplear una rejilla `sf`:
#'
# grid <- buffer %>% st_make_grid(n = c(50, 50), what = "centers") %>% st_intersection(buffer)
#'
#' por comodidad es preferible emplear una rejilla `stars`:
#'
library(stars)
grid <- buffer %>%  st_as_stars(nx = 50, ny = 50)
#'
#' Si suponemos un modelo (no constante) para la tendencia, es necesario añadir los valores de las variables explicativas a la rejilla de predicción:
#'
coord <- st_coordinates(grid)
grid$lon <- coord$x
grid$lat <- coord$y
#'
#' Además, en este caso recortamos la rejilla para filtrar predicciones alejadas de las observaciones:
#'
grid <- grid %>% st_crop(buffer)
#'
#' Obtenemos las predicciones mediante kriging universal (Sección \@ref(kuniversal) y Sección \@ref(kriging-gstat)):
#'
pred <- krige(formula = head ~ lon + lat, locations = aquifer_sf, model = fit,
newdata = grid)
#'
#' ***ERROR en krige***: cambia las coordenadas del objeto stars
#'
summary(st_coordinates(grid))
summary(st_coordinates(pred))
#'
#' Posible solución: añadir el resultado a `grid`:
#'
grid$var1.pred <- pred$var1.pred
grid$var1.var <- pred$var1.var
#'
#' Finalmente representamos las predicciones y las varianzas kriging:
#'
plot(grid["var1.pred"], breaks = "equal", col = sf.colors(64), key.pos = 4,
main = "Predicciones kriging")
plot(grid["var1.var"], breaks = "equal", col = sf.colors(64), key.pos = 4,
main = "Varianzas kriging")
#'
#' También podríamos emplear el paquete `ggplot2`:
#'
library(ggplot2)
library(gridExtra)
p1 <- ggplot() + geom_stars(data = grid, aes(fill = var1.pred, x = x, y = y)) +
scale_fill_viridis_c() + geom_sf(data = aquifer_sf) +
coord_sf(lims_method = "geometry_bbox")
p2 <- ggplot() + geom_stars(data = grid, aes(fill = var1.var, x = x, y = y)) +
scale_fill_viridis_c() + geom_sf(data = aquifer_sf) +
coord_sf(lims_method = "geometry_bbox")
grid.arrange(p1, p2, ncol = 2)
#'
#'
#' ## Validación cruzada
#'
#' Para realizar una diagnosis del modelo de tendencia y variograma (y para seleccionar parámetros o comparar modelos) podemos emplear la técnica de validación cruzada Sección \@ref(validacion-cruzada), mediante la función `krige.cv()`.
#'
#' Por defecto emplea LOOCV y puede requerir de mucho tiempo de computación (no está implementado eficientemente en `gtsat`):
#'
system.time(cv <- krige.cv(formula = head ~ lon + lat, locations = aquifer_sf,
model = fit))
str(cv)
#'
#' Si el número de observaciones es grande puede ser preferible emplear k-fold CV (y como la partición en grupos es aleatoria se recomendaría fijar previamente la semilla de aleatorización):
#'
set.seed(1)
system.time(cv <- krige.cv(formula = head ~ lon + lat, locations = aquifer_sf,
model = fit, nfold = 10))
#'
#' Para seleccionar modelos podemos considerar distintas medidas, implementadas en la siguiente función:
#'
summary_cv <- function(cv.data, na.rm = FALSE,
tol = sqrt(.Machine$double.eps)) {
err <- cv.data$residual      # Errores
obs <- cv.data$observed
z <- cv.data$zscore
w <- 1/pmax(cv.data$var1.var, tol) # Ponderación según varianza kriging
if(na.rm) {
is.a <- !is.na(err)
err <- err[is.a]
obs <- obs[is.a]
z <- z[is.a]
w <- w[is.a]
}
perr <- 100*err/pmax(obs, tol)  # Errores porcentuales
return(c(
# Medidas de error tradicionales
me = mean(err),           # Error medio
rmse = sqrt(mean(err^2)), # Raíz del error cuadrático medio
mae = mean(abs(err)),     # Error absoluto medio
mpe = mean(perr),         # Error porcentual medio
mape = mean(abs(perr)),   # Error porcentual absoluto medio
r.squared = 1 - sum(err^2)/sum((obs - mean(obs))^2), # Pseudo R-cuadrado
# Medidas de error que tienen en cuenta la varianza kriging
dme = mean(z),            # Error estandarizado medio
dmse = sqrt(mean(z^2)),    # Error cuadrático medio adimensional
rwmse = sqrt(weighted.mean(err^2, w)) # Raíz del ECM ponderado
))
}
summary_cv(cv)
#'
#' Las tres últimas medidas tienen en cuenta la estimación de la varianza kriging.
#' El valor del error cuadrático medio adimensional debería ser próximo a 1 si hay concordancia entre las varianzas kriging y las varianzas observadas.
#'
#' Para detectar datos atípicos, o problemas con el modelo, podemos generar distintos gráficos.
#' Por ejemplo, gráficos de dispersión de valores observados o residuos estándarizados frente a predicciones:
#'
old_par <- par(mfrow = c(1, 2))
plot(observed ~ var1.pred, data = cv, xlab = "Predicción", ylab = "Observado")
abline(a = 0, b = 1, col = "blue")
plot(zscore ~ var1.pred, data = cv, xlab = "Predicción", ylab = "Residuo estandarizado")
abline(h = c(-3, -2, 0, 2, 3), lty = 3)
par(old_par)
#'
#' Gráficos con la distribución espacial de los residuos:
#'
plot(cv["residual"], pch = 20, cex = 2, breaks = "quantile", nbreaks = 4)
plot(cv["zscore"], pch = 20, cex = 2)
#'
#' Además de los gráficos estándar para analizar la distribución de los residuos estandarizados o detectar atípicos:
#'
# Histograma
old_par <- par(mfrow = c(1, 3))
hist(cv$zscore, freq = FALSE)
lines(density(cv$zscore), col = "blue")
# Gráfico de normalidad
qqnorm(cv$zscore)
qqline(cv$zscore, col = "blue")
# Boxplot
car::Boxplot(cv$zscore, ylab = "Residuos estandarizados")
par(old_par)
#' comparada con el resto. A partir de la tercera estimación hay un salto de semivarianza.
#'
#' ***
#'
#' **_b. Ajustar a las estimaciones piloto un modelo (isotrópico) de semivariograma
#' exponencial y uno esférico, mediante WLS. ¿Con cuál se obtiene un mejor ajuste?
#' Interpretar las estimaciones obtenidas de los parámetros del semivariograma._**
#'
#'
#' Primero definimos el modelo exponencial con _vgm()_.
modelo_exp <- vgm(model = "Exp", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_exp <- fit.variogram(vario, modelo_exp, fit.method = 2)
fit_exp
fit_exp
nugget <- fit$psill[1]
sill <- nugget + fit$psill[2]
range <- fit$range[2]
nugget
sill
range
nugget <- fit_exp$psill[1]
sill <- nugget + fit_exp$psill[2]
range <- fit_exp$range[2]
nugget
sill
0.3962368 + 3.7978611
range
#' En el caso de un variograma exponencial, el parámetro que aparece como range
#' es un parámetro de escala proporcional al verdadero rango práctico (tres veces ese valor).
#' Asi que multiplicamos por 3:
range <- 3*fit_exp$range[2]
range
#' comparada con el resto. A partir de la tercera estimación hay un salto de semivarianza.
#'
#' ***
#'
#' **_b. Ajustar a las estimaciones piloto un modelo (isotrópico) de semivariograma
#' exponencial y uno esférico, mediante WLS. ¿Con cuál se obtiene un mejor ajuste?
#' Interpretar las estimaciones obtenidas de los parámetros del semivariograma._**
#'
#'
#' Primero definimos el modelo exponencial con _vgm()_.
modelo_exp <- vgm(model = "Exp", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_exp <- fit.variogram(vario, modelo_exp, fit.method = 2)
fit_exp
#' Asignamos a variables para trabajar con ellas posteriormente
nugget <- fit_exp$psill[1]
sill <- nugget + fit_exp$psill[2]
#' En el caso de un variograma exponencial, el parámetro que aparece como range
#' es un parámetro de escala proporcional al verdadero rango práctico (tres veces ese valor).
#' Asi que multiplicamos por 3:
range <- 3*fit_exp$range[2]
#' comparada con el resto. A partir de la tercera estimación hay un salto de semivarianza.
#'
#' ***
#'
#' **_b. Ajustar a las estimaciones piloto un modelo (isotrópico) de semivariograma
#' exponencial y uno esférico, mediante WLS. ¿Con cuál se obtiene un mejor ajuste?
#' Interpretar las estimaciones obtenidas de los parámetros del semivariograma._**
#'
#'
#' Primero definimos el modelo exponencial con _vgm()_.
modelo_exp <- vgm(model = "Exp", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_exp <- fit.variogram(vario, modelo_exp, fit.method = 2)
fit_exp
#' Asignamos a variables para trabajar con ellas posteriormente
nugget <- fit_exp$psill[1]
nugget
sill <- nugget + fit_exp$psill[2]
sill
#' En el caso de un variograma exponencial, el parámetro que aparece como range
#' es un parámetro de escala proporcional al verdadero rango práctico (tres veces ese valor).
#' Asi que multiplicamos por 3:
range <- 3*fit_exp$range[2]
range
#' comparada con el resto. A partir de la tercera estimación hay un salto de semivarianza.
#'
#' ***
#'
#' **_b. Ajustar a las estimaciones piloto un modelo (isotrópico) de semivariograma
#' exponencial y uno esférico, mediante WLS. ¿Con cuál se obtiene un mejor ajuste?
#' Interpretar las estimaciones obtenidas de los parámetros del semivariograma._**
#'
#'
#' Primero definimos el modelo exponencial con _vgm()_.
modelo_exp <- vgm(model = "Exp", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_exp <- fit.variogram(vario, modelo_exp, fit.method = 2)
fit_exp
#' Asignamos a variables para trabajar con ellas posteriormente
nugget_exp <- fit_exp$psill[1]
sill_exp <- nugget_exp + fit_exp$psill[2]
#' En el caso de un variograma exponencial, el parámetro que aparece como range
#' es un parámetro de escala proporcional al verdadero rango práctico (tres veces ese valor).
#' Asi que multiplicamos por 3:
range_exp <- 3*fit_exp$range[2]
range
nugget_exp
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 2,3)
params_exp
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 3,2)
params_exp
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 2, 3)
params_exp
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 2, 3, byrow = TRUE)
params_exp
fit_exp
params_exp <- data.frame(c("nugget_exp", "sill_exp", "range_exp"), c(nugget_exp, sill_exp, range_exp))
params_exp
params_exp <- data.frame(
c("nugget_exp", "sill_exp", "range_exp"),
c(nugget_exp, sill_exp, range_exp))
params_exp
datos <- data.frame(
ID = c(1, 2, 3, 4, 5),
Nombre = c("Juan", "Ana", "Carlos", "Laura", "Marta"),
Edad = c(25, 30, 22, 28, 35),
Puntuacion = c(85, 92, 78, 88, 95)
)
datos
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 2, 3, byrow = TRUE)
params_exp
# Cuidado con plot.variogramModel() si se pretende añadir elementos
# plot(fit, cutoff = maxlag, ylim = c(0, 4.5))
# with(vario,  points(dist, gamma))
plot(vario, fit_exp)
plot.variogramModel(vario, fit_exp)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range, lty = 3)
abline(h = nugget, lty = 3)
abline(h = sill, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 1)
abline(v = 0, lty = 3)
abline(v = 0, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range, lty = 3)
abline(h = nugget, lty = 3)
abline(h = sill, lty = 3)
abline(v = 0, lty = 3, color="blue")
abline(v = 0, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_exp, lty = 3)
abline(h = nugget_exp, lty = 3)
abline(h = sill_exp, lty = 3)
library(sf)
setwd("C:/Users/marti/Desktop/UNI/AEDD/TrabajoXeo/AEDD") # Poned vuestra ruta
load("./datos_trabajo/temp_andalu_8.RData")
head(temp_andalu)
str(temp_andalu)
summary(temp_andalu)
attr(temp_andalu, "fecha") # Mes de las observaciones
#' Asignamos a una variable a la temperatura de la que vamos a realizar un análisis descriptivo unidimensional.
t <- temp_andalu$temp
summary(t)
#' Histograma de la respuesta:
hist(t, xlab = "temperatura", main = "", freq = FALSE)
lines(density(t), col = 'blue')
qqnorm(t)
qqline(t)
#' Test de normalidad de Shapiro-Wilk:
shapiro.test(t)
#' Vamos a convertir los datos a un objeto sf.
#' Mantenemos lan y lot como posibles variables expicativas.
crs <- "+proj=utm +zone=30 +ellps=WGS84 +units=km" # Definimos el CRS
temp_andalu_sf <- st_as_sf(temp_andalu, coords = c("lon", "lat"), remove = FALSE, agr = "constant", crs = crs)
#' Representación de la distribución espacial de la respuesta, asignando un color dependiendo de la temperatura medida en cada observación.
plot(temp_andalu_sf["temp"], pch = 20, cex = 2, breaks = "quantile", nbreaks = 4)
x <- temp_andalu_sf$lon
y <- temp_andalu_sf$lat
old.par <- par(mfrow = c(1, 2), omd = c(0.05, 0.95, 0.01, 0.95))
plot(x, t) # lon frente a temperatura
lines(lowess(x, t), lty = 2, lwd = 2, col = 'blue')
plot(y, t) # lat frente a temperatura
lines(lowess(y, t), lty = 2, lwd = 2, col = 'blue')
par(mfrow = c(1,1))
#' Ajustamos el modelo por ols
temp.ols <- lm(temp ~ lon + lat, data = temp_andalu_sf)
summary(temp.ols)
#' Analizamos los residuos
res <- residuals(temp.ols)
summary(res)
#' Hacemos un histograma de los residuos
hist(res, xlab = "ols residuals", main = "", freq = FALSE)
lines(density(res), col = 'blue')
qqnorm(res)
qqline(res)
#' Test de normalidad de Shapiro-Wilk
shapiro.test(res)
library(mapSpain)
library(ggplot2)
andalucia_limites <- mapSpain::esp_get_ccaa(ccaa="andalucia")
#' Creamos los cuantiles para la distribuir los colores
quantiles <- quantile(temp_andalu_sf$temp, probs = c(0, 0.25, 0.5, 0.75, 1))
#' Hacemos el grafico usando ggplot juntando los límites de Andalucía junto a
#' la representación de la distribución espacial de la respuesta
#'
ggplot() +
geom_sf(data = andalucia_limites, fill = "transparent", color = "black", lwd = 1) +
geom_sf(data = temp_andalu_sf, aes(color = temp_andalu_sf$temp), pch = 20, cex = 5) +
scale_color_gradient(breaks = quantiles, low = "blue", high = "red", name = "Temperatura") +
ggtitle("Temperatura en el mes de enero de 2022 en la comunidad de Andalucía")
library(gstat)
maxlag <- 290 # Salto máximo de 290
# Estimador clásico del semivariograma-> cressie = False
vario <- variogram(temp ~ lon + lat, temp_andalu_sf, cutoff = maxlag, width = maxlag/20)
#' Represantación de las estimaciones junto con el número de aportaciones:
plot(vario, plot.numbers = TRUE)
#' comparada con el resto. A partir de la tercera estimación hay un salto de semivarianza.
#'
#' ***
#'
#' **_b. Ajustar a las estimaciones piloto un modelo (isotrópico) de semivariograma
#' exponencial y uno esférico, mediante WLS. ¿Con cuál se obtiene un mejor ajuste?
#' Interpretar las estimaciones obtenidas de los parámetros del semivariograma._**
#'
#'
#' Primero definimos el modelo exponencial con _vgm()_.
modelo_exp <- vgm(model = "Exp", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_exp <- fit.variogram(vario, modelo_exp, fit.method = 2)
fit_exp
#' Asignamos a variables para trabajar con ellas posteriormente
nugget_exp <- fit_exp$psill[1]
sill_exp <- nugget_exp + fit_exp$psill[2]
#' En el caso de un variograma exponencial, el parámetro que aparece como range
#' es un parámetro de escala proporcional al verdadero rango práctico (tres veces ese valor).
#' Asi que multiplicamos por 3:
range_exp <- 3*fit_exp$range[2]
#' Parámetros del semivariograma:
params_exp <- matrix(c("nugget_exp", "sill_exp", "range_exp", nugget_exp, sill_exp, range_exp), 2, 3, byrow = TRUE)
plot(vario, fit_exp)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
lines(variogramLine(fit, maxdist = max(range*1.1, maxlag)))
abline(v = 0, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_exp*1.1, maxlag)), ylim = c(0, sill_exp*1.1))
lines(variogramLine(fit_exp, maxdist = max(range_exp*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_exp, lty = 3)
abline(h = nugget_exp, lty = 3)
abline(h = sill_exp, lty = 3)
plot(vario$dist, vario$gamma, xlab = "distance", ylab =  "semivariance",
xlim = c(0, max(range*1.1, maxlag)), ylim = c(0, sill*1.1))
plot(vario, fit_exp)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_exp*1.1, maxlag)), ylim = c(0, sill_exp*1.1))
lines(variogramLine(fit_exp, maxdist = max(range_exp*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_exp, lty = 3)
abline(h = nugget_exp, lty = 3)
abline(h = sill_exp, lty = 3)
#' Ahora definimos el modelo esférico con _vgm()_.
modelo_sph <- vgm(model = "Sph", nugget = NA) # Valores iniciales por defecto
#' Ahora definimos el modelo esférico:
modelo_sph <- vgm(model = "Sph", nugget = NA) # Valores iniciales por defecto
#' Ajustamos el modelo con _fit.variogram()_ empleando pesos inversamente proporcionales a la varianza (_fit.method = 2_)
fit_sph <- fit.variogram(vario, modelo_sph, fit.method = 2)
fit_sph
fit_sph
#' Asignamos a variables para trabajar con ellas posteriormente
nugget_sph <- fit_sph$psill[1]
sill_sph <- nugget_sph + fit_sph$psill[2]
#' En el caso de un variograma esférico el parametro _range_ ya es el verdadero rango práctico.
range_sph <- 3*fit_sph$range[2]
#' Parámetros del semivariograma:
params_sph <- matrix(c("nugget_sph", "sill_sph", "range_sph", nugget_sph, sill_sph, range_sph), 2, 3, byrow = TRUE)
params_sph
#' En el caso de un variograma esférico el parametro _range_ ya es el verdadero rango práctico.
range_sph <- fit_sph$range[2]
#' Parámetros del semivariograma:
params_sph <- matrix(c("nugget_sph", "sill_sph", "range_sph", nugget_sph, sill_sph, range_sph), 2, 3, byrow = TRUE)
params_sph
plot(vario, fit_sph)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.1))
lines(variogramLine(fit_sph, maxdist = max(range_sph*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_sph, lty = 3)
abline(h = nugget_sph, lty = 3)
abline(h = sill_sph, lty = 3)
plot(vario, fit_sph)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.1))
plot(vario, fit_sph)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.2, maxlag)), ylim = c(0, sill_sph*1.2))
lines(variogramLine(fit_sph, maxdist = max(range_sph*1.1, maxlag)))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.2))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.1))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.2))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.2, maxlag)), ylim = c(0, sill_sph*1.2))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.2, maxlag)), ylim = c(0, sill_sph*1.2))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_exp*1.1, maxlag)), ylim = c(0, sill_exp*1.1))
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_exp*1.1, maxlag)), ylim = c(0, sill_exp*1.2))
lines(variogramLine(fit_exp, maxdist = max(range_exp*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_exp, lty = 3)
abline(h = nugget_exp, lty = 3)
abline(h = sill_exp, lty = 3)
plot(vario, fit_sph)
plot(vario, fit_exp)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_exp*1.1, maxlag)), ylim = c(0, sill_exp*1.2))
lines(variogramLine(fit_exp, maxdist = max(range_exp*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_exp, lty = 3)
abline(h = nugget_exp, lty = 3)
abline(h = sill_exp, lty = 3)
plot(vario, fit_sph)
plot(vario$dist, vario$gamma, xlab = "distance", ylab = "semivariance",
xlim = c(0, max(range_sph*1.1, maxlag)), ylim = c(0, sill_sph*1.2))
lines(variogramLine(fit_sph, maxdist = max(range_sph*1.1, maxlag)))
abline(v = 0, lty = 3)
abline(v = range_sph, lty = 3)
abline(h = nugget_sph, lty = 3)
abline(h = sill_sph, lty = 3)
#' Vamos a comparar los dos modelo a través del valor mínimo de la función objetivo WLS.
#' Modelo exponencial:
attr(fit_exp, "SSErr")
#' Modelo esférico:
attr(fit_sph, "SSErr")
